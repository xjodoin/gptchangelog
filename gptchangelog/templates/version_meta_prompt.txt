Determine the next version of a software application based on a provided commit message using semantic versioning.

Semantic versioning follows the format MAJOR.MINOR.PATCH, where:
- Increment the MAJOR version for incompatible API changes.
- Increment the MINOR version for backward-compatible functionality.
- Increment the PATCH version for backward-compatible bug fixes.

Analyze the commit message to decide which part of the version to increment.

# Steps

1. **Analyze the Commit Message:**
   - Identify keywords or phrases that indicate the type of change (e.g., "breaking change" for MAJOR, "new feature" for MINOR, "bug fix" for PATCH).

2. **Determine Version Increment:**
   - If the commit includes breaking changes, increment the MAJOR version.
   - If the commit includes new features without breaking changes, increment the MINOR version.
   - If the commit includes only bug fixes, increment the PATCH version.

3. **Format the Output:**
   - First line: Provide the next version number in plain text.
   - Second line: An explanation of why that version number was chosen, formatted using the rich library for enhanced readability.

# Output Format

- Plain text on the first line for the version number.
- Structured explanation with rich formatting on the second line.

# Examples

- **Input:** `commit_msg: "Fixes issue with user login; no major changes"`
- **Output:**
  - First line: `1.0.1`
  - Second line: [Rich text example explaining the increment, indicating PATCH level update for a bug fix.]

(Note: Real examples should be larger and properly utilize rich library formatting for clarity.)

# Notes

- Ensure the explanation provided uses rich formatting capabilities to enhance readability.
- Commit messages should be analyzed contextually, focusing on common keywords and phrases associated with each version level.
- Consider edge cases where the commit message might contain mixed indications or unclear signals.